use 'libs/stack.baabnq';
use 'libs/ouch/syscall.baabnq';
use 'libs/no.baabnq';

"base screen port
put _XBASEPORT = 6000;

"interface, default ip -> localhost
put _XLib::HostLow  = (0 << 8)   + 1; "???.???.000.001
put _XLib::HostHigh = (127 << 8) + 0; "127.000.???.???
put _XLib::ScreenNum = 0;

put _XLib::DisplayWidth = 100;
put _XLib::DisplayHeight = 100;

"long (32) = 2 word (16) = 2 shorts (16)
static 2 _XResourceAcc;
static 2 _XContentID;

static 2 _XRootWinID;

put _XpSock = 0;



"!!!! NON OF THESE TAKE ARGS !!!!

jump XLib::Skip;

"this only works, because we assume that the lower few bytes are empty
"this is however ususally the case, because of resource_mask looking something like 0x1ffff
lab XLib::XAllocID;
    "put __     <- _XResourceAcc;
    "put __ + 1 -> _XResourceAcc;
    
    asm '
    lPA (_XResourceAcc);
    set 1;
    add;
    sAP (_XResourceAcc);
    ';


    return;

"recv cons parser util
lab XLib::XCons;
    "check recv, loop if data not yet available
    push _XpSock;
    sub Ouch::Syscall::ReadStream;
    pull _suc;
    pull _data;
    jump XLib::XCons ~ _suc == 2;
    sub  No::Panic   ~ _suc == 0;
    
    push _data;
    sub Stack::Swap;
    return;

"recv cons parser util
lab XLib::XConsShort;
    sub XLib::XCons;
    pull _low;
    sub XLib::XCons;
    pull _high;

    push (_high << 8) + _low;
    sub Stack::Swap;
    return;    


"opens window, based on globals
lab XLib::XOpenDisplay;
    
    push _XBASEPORT + _XLib::ScreenNum;
    push _XLib::HostLow;
    push _XLib::HostHigh;
    sub Ouch::Syscall::Connect;
    pull _XpSock;
    sub No::Return ~ _XpSock == 0;
    

    "client prefix string
    "new 'B\x0b\x00\x00\x00' _pStr;
    new 'l\x0b\x00\x00\x00\x00' _pStr;
    put _len <- _pStr - 1;
    put _len = _len - 2;

    push _XpSock;
    push _pStr;
    push _len;
    sub Ouch::Syscall::SendStream;
    pull _suc;
    sub No::Return ~ _suc == 0;

    free _pStr;




    "read response
    sub XLib::XCons; pull _suc;
    sub XLib::XCons; pull __;

    sub No::Panic ~ _suc != 1;

    "version numbers
    sub XLib::XConsShort; pull __; sub No::Return ~ __ != 11; "major = 11
    sub XLib::XConsShort; pull __; sub No::Return ~ __ != 0;  "minor = 0
    
    sub XLib::XConsShort; pull _len;
    put _len = _len << 2;
    print _len;
    
    "setup
    new _len _pBuf;
    put _p = _pBuf;
    
    put _i = 0;
    lab XLib::XOpenDisplay::SetupLoop;
        sub XLib::XCons;
        pull _data;
        put _data -> _pBuf + _i;
        put _i = _i + 1;
    jump XLib::XOpenDisplay::SetupLoop ~ _i < _len;

    "parse (hell)
    put _p = _p + 4; "skip release number

    "resource base id    
    put _low  <- _p + 0;
    put _high <- _p + 1;
    put _low | (_high << 8) -> _XResourceAcc + 0;    
    put _low  <- _p + 2;
    put _high <- _p + 3;
    put _low | (_high << 8) -> _XResourceAcc + 1;


    put _p = _p + 4 + 4 + 4; "resource base id + mask id + motion size buffer
    put _venlen <- _p;
    put _p = _p + 2 + 2; "vendor len + max req len
    
    put __ <- _p;
    put _numFormat <- _p + 1;
    sub No::Panic ~ __ != 1; "only one screen supported
    put _p = _p 
+ 1 "number screem
+ 1 "number format
+ 1 "image byte order
+ 1 "bitmap byte order
+ 1 "bitmap scanline unit
+ 1 "bitmap scanline pad
+ 1 "min keycode
+ 1 "max keycode
+ 4; "unused

    put _i = 0;
    lab XLib::XOpenDisplay::VenLoop;
        put _data <- _p + _i;
        putchr _data;
        put _i = _i + 1;
    jump XLib::XOpenDisplay::VenLoop ~ _i < _venlen;
    putchr 10;
    put _p = _p + _venlen + 1;
    

    "skip format, sizeof(format) = 8 bytes
    put _p = _p + (_numFormat << 3) - 1;

    "root window id
    put _low  <- _p + 0;
    put _high <- _p + 1;
    put _low | (_high << 8) -> _XRootWinID + 0;    
    put _low  <- _p + 2;
    put _high <- _p + 3;
    put _low | (_high << 8) -> _XRootWinID + 1;


    "done parsing connection startup
    free _pBuf;

    "graphics context
    sub XLib::XAllocID;
    push _XResourceAcc;
    push _XContentID;
    push 2;
    sub String::MemCpy;

    new '\x37\x04\x00\x00\x00\x00\x00\x00' _pStr;
    put _len <- _pStr - 1;
    put _len = _len - 2;    

    push _XContentID;
    push _pStr + 2;
    push 2;
    sub String::MemCpy;

    push _XRootWinID;
    push _pStr + 4;
    push 2;
    sub String::MemCpy;

    push _XpSock;
    push _pStr;
    push _len;
    sub Ouch::Syscall::SendStream;
    pull _suc;
    sub No::Return ~ _suc == 0;

    free _pStr;

    return;


"(X::Int, Y::Int, Width::Int, Height::Int) => (WinID::Long)
lab XLib::XCreateWindow;
    sub Stack::Swap;
    pull _Height;
    sub Stack::Swap;
    pull _Width;
    sub Stack::Swap;
    pull _Y;
    sub Stack::Swap;
    pull _X;
    
    "new window id
    new 2 _pWin;
    sub XLib::XAllocID;
    push _XResourceAcc;
    push _pWin;
    push 2;
    sub String::MemCpy;

    
    "request
    new '\x01\x08\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x00\x00\x00\x00' _pStr;
    put _len <- _pStr - 1;
    put _len = _len - 2;
    
    push _pWin;
    push _pStr + 2;
    push 2;
    sub String::MemCpy;
    push _XRootWinID;
    push _pStr + 4;
    push 2;
    sub String::MemCpy;

    put _X -> _pStr + 6;
    put _Y -> _pStr + 7;
    put _Width -> _pStr + 8;
    put _Height -> _pStr + 9;
    

    push _XpSock;
    push _pStr;
    push _len;
    sub Ouch::Syscall::SendStream;
    pull _suc;
    sub No::Return ~ _suc == 0;


    free _pStr;

    push _pWin;
    sub Stack::Swap;
    return;



"(WinID::Long)
lab XLib::XMapWindow;
    sub Stack::Swap;
    pull _pWin;
    
    new '\x08\x02\x00\x00' _pStr;
    put _len <- _pStr;
    put _len = _len - 2;

    push _pWin;
    push _pStr + 2;
    push 2;
    sub String::MemCpy;

    push _XpSock;
    push _pStr;
    push _len;
    sub Ouch::Syscall::SendStream;
    pull _suc;
    sub No::Return ~ _suc == 0;

    free _pStr;
    return;    




lab XLib::Skip;



sub XLib::XOpenDisplay;

push 10;
push 10;
push 1000;
push 500;
sub XLib::XCreateWindow;
pull _pWin;

print _pWin;

push _pWin;
sub XLib::XMapWindow;


push 10000;
sub Ouch::Syscall::NapMs;




asm 'brk';











