use 'libs/math.baabnq';
use 'libs/stack.baabnq';
jump String::Skip;


lab String::PrintString;
    sub Stack::Swap;
    pull _StringPtr;


    lab String::PrintString::PrintLoop;
    put _Data <- _StringPtr;
    jump String::PrintString::Exit ~ _Data == 0;

    putchr _Data;

    put _StringPtr = _StringPtr + 1;
    jump String::PrintString::PrintLoop;
    lab String::PrintString::Exit;
    return;


"string rendering and parsing ------------

"takes a list of char from the stack and converts it into an int
"order of char can be changed be setting config to a 1
lab String::StackChar2Int;
    sub Stack::Swap;
    pull _Config;
    put _Buffer = 0;
    put _IndexInit = 0;

    "init _Index to a value base on config
    sub String::StackChar2Int::SetIndexInit1     ~ _Config == 0;
    sub String::StackChar2Int::SetIndexInit10000 ~ _Config == 1;
    put _Index = _IndexInit;

    lab String::StackChar2Int::AccLoop;
    sub Stack::Swap;
    pull _Data; 
    "check for terminator
    jump String::StackChar2Int::Exit ~ _Data == 0;

    push _Data - 48; 
    push _Index; 
    sub Math::Mul; 
    pull _Data; 
    put _Buffer = _Buffer + _Data;

    push _Index;
    push 10;
    sub Math::Mul ~ _Config == 0;
    sub Math::Div ~ _Config == 1;
    pull _Index;

    jump String::StackChar2Int::AccLoop ~ _Index != _IndexInit;
    lab String::StackChar2Int::Exit;

    push _Buffer;
    sub Stack::Swap;
    return;

    lab String::StackChar2Int::SetIndexInit1;
        put _IndexInit = 1;
        return;
    lab String::StackChar2Int::SetIndexInit10000;
        put _IndexInit = 10000;
        return;


"takes number, converts it to string
"THIS WILL ALLOCATE MEMORY
lab String::Int2Str;
    sub Stack::Swap;
    pull _Num;

    "16-bit int limit is 65535, so 5 digits plus terminator
    new 6 _pStr;
    put 0 -> _pStr + 5;
    put _pWrite = _pStr;

    "keep track of trailing
    put _IsContent = 0;
    
    "populate string from start to end
    put _PlaceVal = 10000;
    put _Index = 0;
    lab String::Int2Str::Loop;
        put _Count = 0;
        lab String::Int2Str::DivLoop;
            jump String::Int2Str::DivDone ~ _Num == 0;
            jump String::Int2Str::DivDone ~ _Num < _PlaceVal;
            put _Count = _Count + 1;
            put _Num = _Num - _PlaceVal;
        jump String::Int2Str::DivLoop;
        lab String::Int2Str::DivDone;

        push _Index; "i love baabnq

        push _PlaceVal;
        push 10;
        sub Math::Div;
        pull _PlaceVal;

        pull _Index;

        "check trailing, _IsContent is 0 while _Count is 0, that's why we or
        put _IsContent = _IsContent | _Count;

        "skip trailing 0s
        jump String::Int2Str::SkipWrite ~ _IsContent == 0;
            put _Count + 48 -> _pWrite;
            put _pWrite = _pWrite + 1;
        lab String::Int2Str::SkipWrite;

        put _Index = _Index + 1;
    jump String::Int2Str::Loop ~ _Index < 5;

    "special case
    jump String::Int2Str::SkipSpe ~ _IsContent != 0;
        put 48 -> _pStr;
    lab String::Int2Str::SkipSpe;

    push _pStr;
    sub Stack::Swap;
    
    return;

    



"general string manipulation ---------

"takes a string pointer from the stack and returns it's length ('' -> 0, 'a' -> 1)
lab String::StrLen;
    pull _ReturnAddr;
    pull _StringPtr;


    put _SizeBuffer = 0;
    lab String::GetSize::CountLoop;
    put _Data <- _SizeBuffer + _StringPtr;

    jump String::GetSize::Exit ~ _Data == 0;

    put _SizeBuffer = _SizeBuffer + 1;
    jump String::GetSize::CountLoop;
    lab String::GetSize::Exit;


    push _SizeBuffer;
    push _ReturnAddr;
    return;
    
"string copy
"SrcPtr
"DestPtr
"Size
"name totally not stolen from c
lab String::MemCpy;
    pull _ReturnAddr;
    pull _Size;
    pull _DestPtr;
    pull _SrcPtr;

    put _Index = 0;

    lab String::MemCpy::Loop;
    put _Data <- _SrcPtr  + _Index;
    put _Data -> _DestPtr + _Index;

    put _Index = _Index + 1;
    jump String::MemCpy::Loop ~ _Size != _Index;


    push _ReturnAddr;
    return;


"scan string for character
"StrPtr
"Char
lab String::ScanChar;
    pull _ReturnAddr;
    pull _Char;
    pull _StrPtr;

    lab String::ScanChar::IterLoop;
        put _Data <- _StrPtr;
        put _StrPtr = _StrPtr + 1;
        
        
        jump String::ScanChar::Found    ~ _Data == _Char;
        jump String::ScanChar::IterLoop ~ _Data != 0;
        

    push 0;
    push _ReturnAddr;
    return;

    lab String::ScanChar::Found;
        push 1;
        push _ReturnAddr;
        return;

"takes 2 string pointer and concatenates them
lab String::Concat;
    pull _ReturnAddr;
    pull _StrPtr2;
    pull _StrPtr1;
    push _ReturnAddr;    

    push _StrPtr1;
    sub String::GetSize;
    pull _StrLen1;
    push _StrPtr2;
    sub String::GetSize;
    pull _StrLen2;

    "restore retrun address
    pull _ReturnAddr;
    
    "+ 1 for terminator
    new _StrLen1 + _StrLen2 + 1 _StrPtrFinal;

    put _Index = 0;
    lab String::Concat::StrCopyLoop1;
        put _Data <- _StrPtr1 + _Index;
        jump String::Concat::StrCopyExit1 ~ _Data == 0;

        put _Data -> _StrPtrFinal + _Index;
        put _Index = _Index + 1;
        jump String::Concat::StrCopyLoop1;
    lab String::Concat::StrCopyExit1;

    put _Index = 0;

    "start to write the 2nd string after the first for obvious reasons
    put _StrPtrFinalShifted = _StrPtrFinal + _StrLen1;
    lab String::Concat::StrCopyLoop2;
        put _Data <- _StrPtr2 + _Index;
        jump String::Concat::StrCopyExit2 ~ _Data == 0;

        put _Data -> _StrPtrFinalShifted + _Index;
        put _Index = _Index + 1;
        jump String::Concat::StrCopyLoop2;        
    lab String::Concat::StrCopyExit2;

    push _StrPtrFinal;
    push _ReturnAddr;
    return;


"takes const char** and join strings into one DOES NOT DEALLOC
"substr most contain size at -1, too lazy to implement properlly
lab String::Join;
    sub Stack::Swap;
    pull _pStrs;

    "calculate final len
    put _Count = 0;
    put _Index = 0;
    lab String::Join::Count;
        put _pSub <- _pStrs + _Index;
        jump String::Join::CountDone ~ _pSub == 0;
        push _pSub; 
        sub String::StrLen; 
        pull _Size;
        put _Count = _Count + _Size;
        put _Index = _Index + 1;
    jump String::Join::Count;
    lab String::Join::CountDone;

    "alloc
    new _Count + 1 _pOut;
    put 0 -> _pOut + _Count;    

    "copy
    put _iStrs = 0;
    put _iOut = 0;
    lab String::Join::Copy;
        put _pSub <- _pStrs + _iStrs;
        put _iStrs = _iStrs + 1;
        jump String::Join::CopyDone ~ _pSub == 0;

        push _pSub; 
        sub String::StrLen; 
        pull _Size;

        push _pSub;
        push _pOut + _iOut;
        push _Size;
        put _iOut = _iOut + _Size; "move _pOut over to free memory
        sub String::MemCpy;

    jump String::Join::Copy;
    lab String::Join::CopyDone;

    push _pOut;
    sub Stack::Swap;
    return;


lab String::Skip;

